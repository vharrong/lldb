# -*- mode: ruby -*-
# vi: set ft=ruby :

# This script requires the following vagrant plugins to be installed like so:
#   vagrant plugin install vagrant-triggers

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  # chef/freebsd-10.0 has too small a home directory.  We run out of space during build.
  # This is the best vmware option thus far. Solve the disk space issue.
  config.vm.box = "chef/freebsd-10.0"
  
  # The VMWare version of the chef/freebsd-10.0 box does not have
  # bash installed, but the shell provisioner expects bash to be there.
  # Change the shell for the shell provisioner.
  config.ssh.shell = "/bin/sh"

  # On FreeBSD, the default Vagrant synced_folder mechanism doesn't work.
  # We need to use an extra private network (host/guest-only) and NFS.
  config.vm.network :private_network, ip: "10.0.5.2"
  config.vm.synced_folder ".", "/vagrant", :nfs => true

  guest_memory_mb  = ENV["LLDB_GUEST_MEMORY_MB"] || 12 * 1024
  guest_core_count = ENV["LLDB_GUEST_CORE_COUNT"] || 6 
  vm_disk_dir = "#{ENV['HOME']}/vagrant-disks/freebsd_lldb"
  vm_disk_prefix = "#{vm_disk_dir}/freebsd_lldb"

  #
  # Provider (hypervisor)-specific configuration.
  #
  
  # VMWare Fusion configuration.
  config.vm.provider "vmware_fusion" do |v|
    # We want 8 GB RAM, 4 CPUs.
    # You may need to shrink this if your host has fewer resources.
    v.vmx["memsize"] = "#{guest_memory_mb}"
    v.vmx["numvcpus"] = "#{guest_core_count}"
    
    # Show the GUI when you have startup issues.
    v.gui = true

    # Create a second disk for lldb.
    vdiskmanager_exe = '/Applications/VMware\ Fusion.app/Contents/Library/vmware-vdiskmanager'

    unless File.directory?(vm_disk_dir)
        Dir.mkdir vm_disk_dir
    end

    vm_disk_filename = "#{vm_disk_prefix}.vmdk"
    unless File.exists?(vm_disk_filename)
        `#{vdiskmanager_exe} -c -s 25GB -a lsilogic -t 1 #{vm_disk_filename}`
    end

    v.vmx['scsi0:1.filename'] = vm_disk_filename
    v.vmx['scsi0:1.present']  = 'TRUE'
    v.vmx['scsi0:1.redo']     = ''
  end
  
  # VirtualBox configuration.
  config.vm.provider "virtualbox" do |vb|
    vb.memory = guest_memory_mb
    vb.cpus   = guest_core_count
    vb.customize ["modifyvm", :id, "--nictype1", "virtio"]
    vb.customize ["modifyvm", :id, "--nictype2", "virtio"]

    # Show the GUI when you have startup issues.
    vb.gui = true
  end
  
  # Create a forwarded port mapping which allows access the guest with
  # a local port.
  local_guest_port = ENV["LLDB_PORT_FREEBSD_10.0_X86_64"] || 2023
  config.vm.network "forwarded_port", guest: 22, host: local_guest_port

  # Configure the box with our bootstrap.sh file.
  config.vm.provision :shell, path: "bootstrap.sh"

  # Cleanup of second vm disk if found, only after destroy.
  config.trigger.after :destroy do
    run "rm -rf #{vm_disk_dir}"
  end

end
